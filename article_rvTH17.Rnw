\documentclass[article]{jss}

%% -- LaTeX packages and custom commands ---------------------------------------

%% recommended packages
\usepackage{thumbpdf,lmodern}
\usepackage{float,tikz}
%% another package (only for this demo article)
\usepackage{framed}
%% author pakckage
\usepackage{xcolor,caption, float}
\usepackage{array}

\graphicspath{ {./imgs/} }

%% new custom commands
\newcommand{\class}[1]{`\code{#1}'}
\newcommand{\fct}[1]{\code{#1()}}

%% This modifies which proportion of the page must be occupied by the figure
%% or table to take the full page (with no additional text).
%% Check if the journal does not have any rule about not changing this.
\renewcommand{\floatpagefraction}{.8}

% \setlist[itemize]{noitemsep, topsep=0pt}
<<preliminaries, echo=FALSE, include=FALSE, cache=FALSE >>=
# options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
library("MASS")
library("extrafont") #;library("ggplot")
library("igraph")
opts_chunk$set(prompt=TRUE, fig.pos = '!htbp', results='asis', highlight=FALSE,
               class.source = "bg-success")
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
options(SweaveHooks=list(fig=function() par(mar=c(0, 0, 0, 0))))
# options(replace.assign=TRUE, width=90, prompt="R> ")
opts_knit$set(concordance=TRUE, self.contained=FALSE, background = "#FFFFFF")
# knitr::opts_chunk$set(fig.pos = '!htbp')
loadfonts(device = "win")
@

%% -- Article metainformation (author, title, ...) -----------------------------

%% - \author{} with primary affiliation
%% - \Plainauthor{} without affiliations
%% - Separate authors by \And or \AND (in \author) or by comma (in \Plainauthor).
%% - \AND starts a new line, \And does not.
\author{Thomas Huet\\UMR 5140 \And Craig Alexander \And Jose Pozo}
%   \And Second Author\\Plus Affiliation}
\Plainauthor{Thomas Huet, Craig Alexander, Jose Pozo}

%% - \title{} in title case
%% - \Plaintitle{} without LaTeX markup (if any)
%% - \Shorttitle{} with LaTeX markup (if any), used as running title
\title{Modelling Prehistoric Iconographic Compositions. The \proglang{R} package \pkg{decorr}}
\Plaintitle{Modelling Prehistoric Iconographic Compositions. The R package 'decorr'}
\Shorttitle{Modelling Prehistoric Iconographic Compositions}

%% - \Abstract{} almost as usual
\Abstract{
By definition, Prehistorical societies are characterised by the absence of a writing system. During, the largest part of human history -- from far -- symbolic expressions belong to illiterate societies which express themself with rock-art paintings, pottery decorations, figurines and statuary, etc., and a lot of now disappeared carved woods, textil design, etc. At the composition level, recognition of meaningful associations of signs and reccurent patterns indicate clearly the existence of social conventions in the way to display and to read these expressions.
We present the \pkg{decorr} \proglang{R} package which grounds concepts, methods and tools to analyse any ancient graphical systems. Our asumption is that i) any graphical system is a spatial distribution of features, and ii) these features have possibly any meaningful relationships one with another depending on their pairwise spatial proximities. To model the graphical compositions we employ concepts coming from the Graph Theory. To ensure the feasability of this type of analysis, we propose a GIS-based method for inputs and a serie of functions for data management.
}

\Keywords{Semiotics, Iconography, Prehistory, Graphs, Spatial Analysis, Binary Topological Relationships (\emph{birel}), \proglang{R}}
\Plainkeywords{Semiotics, Iconography, Prehistory, Graphs, Spatial Analysis, Binary Topological Relationships (birel), R}

\Address{
Thomas Huet\\
CNRS-UMR 5140 \\
Archeologie des Societes Mediterraneennes\\
Universite Paul Valery\\
route de Mende\\
Montpellier 34199, France\\
E-mail: \email{thomashuet7@gmail.com}\\
%  URL: \url{https://eeecon.uibk.ac.at/~zeileis/}
}

\begin{document}
%\SweaveOpts{concordance=TRUE}
% \SweaveOpts{concordance=TRUE}
% \Sweave2knitr("article_rvTH14_1.Rnw")
% \SweaveOpts{concordance=TRUE}

\section[Introduction]{Introduction} \label{sec:intro}

Symbolic practices is a characteristic trait of human societies. Even discussed, such practices seems to start between 233,000 to 800,00 BC \citep{dErrico00}, covering more than 97\% of total human societies time span. Symbolism cover a large range of practices, from ochre deposit in a tomb, to menhir alignements, passing through wall fresco. This latter, what might be called "iconographical practices", probably shows the most complex and interesting testimonies of past societies symbolism. For decades, its study was linked to history of religion because commonly seen as closely linked to cultual practices and believes. Since the \textit{New Archaeology} developpement during the 60's \citep{Clarke14}, symbolic expressions start to be studied with the same formal methods (statistics, seriations, distribution maps, etc.) as any another aspect of social organisation: settlement patterns, tools \emph{chaine op\'eratoire}, susbsitence strategies, etc. \citep{Renfrew91}. But unlike many aspects of the material culture where technological requirements and technical efficiency determine the choice of the raw material and the shape of the object -- a flint blade for cutting, a pottery for containing, a house for living --, the function of an iconographic composition cannot be drawn directly from itself. Furthermore, there is no specific and controled vocabularies to describe hand-made images. There is always a difficulty to decribe an iconographical content with alphanumerical signs. Whether these last decades study of ancient iconography had  undergone significative improvements at the site scale -- with GIS/database statistics, paleoenvironmental restitutions, etc. -- and at the sign scale with the development of archaeological sciences -- radiocarbon dating, use-wear analysis, elemental analysis, etc. --, these improvement do not necessarly help to understand the semantic content of the iconography.\\
Semantics or semiotics can be defined as a system of conventional features -- called signs -- organised also in conventional manners. Until our days, formal methods to study ancient iconography semantics have been mostlty been grounded  -- explicitly or not -- on the prime principle of Saussurian linguistic: the '\emph{linearity of the signifier}' \citep{Saussure89}.
Writing is one of the most rational semiographical system with a clear distinction between signified and signifier and the development of the signified on a linear axis. Even if we do not understand the meaning of the signs, writing can easily be modelled with Graph theory and recurent patterns can be identified. For example, the 3-letters word "\code{art}" can be modelled with three vertices (\code{a}, \code{r}, \code{t}) and two edges (one between \code{a} and \code{r}, the other between \code{r} and \code{t}). In \proglang{R}, these features, concatenated in this order with a \code{paste0()}, is \code{art}, and not \code{rat} (Fig. \ref{fig:fart}).

<<a_r_t, echo=FALSE, message=FALSE, warning=FALSE, fig.pos = '!htbp', fig.align="center", fig.width=1.25, fig.height=0.25, fig.cap="\\label{fig:fart}Concatenate of 'a', 'r' and 't' graphical units is 'art'">>=
par(mar=c(0.1,0.1,0.1,0.1) )
g <- graph_from_literal(a-+r, r-+t)
plot(g,
     layout = cbind(seq(-1,1,length.out = gorder(g)), 0),
     vertex.color="white",
     vertex.frame.color="white",
     vertex.size=40,
     vertex.label.cex=1,
     vertex.label.color="black",
     vertex.label.family="Courier",
     edge.arrow.size=0.5,
     xlim=c(-0.94,0.94), 
     ylim=c(-1,-1))
@

But, as stated, in Prehistorical the writing system does not exists. Spatial relationships between graphical features, or graphical units, are not necessarly linear and directed but could most probably be more multi-directional and undirected: the direction of the interactions of pairwise graphical units can be in any order (Fig. \ref{fig:fratar}).

<<echo=FALSE, message=FALSE, warning=FALSE, fig.pos = '!htbp', fig.align="center", fig.width=1.4, fig.height=1.4, fig.cap="\\label{fig:fratar}Potential spatial relations between graphical units">>=
par(mar=c(0,0,0,0))
ugs <- data.frame(name=c("a","r","t"))
lks <- data.frame(from=c("a", "r", "t"), to=c("r", "t", "a"), type=c("=","=","="))
g <- igraph::graph_from_data_frame(lks, directed=FALSE, vertices= ugs)
plot(g,
     vertex.color="white",
     vertex.frame.color="white",
     vertex.size=80,
     vertex.label.cex=1,
     vertex.label.color="black",
     vertex.label.family="Courier",
     xlim=c(-0.65,0.65), 
     ylim=c(-0.65,0.65)
)
@

Because of the inherent variability of iconography, and because graphical and spatial proximities between graphical units are generaly not quantified, applying the Saussurian model to any prehistorical graphical content had led to considerable problems:
\begin{itemize}
\setlength\itemsep{.05em}
\item unexplicit spatial groupings of graphical units -- like graphical units grouped into \emph{figures},  \emph{figures} grouped into \emph{patterns}, \emph{patterns} grouped into \emph{motives}, etc. -- with tedious number of groups
\item consistency, proximities and relationships between these groups are often implicit and not quantified
\item studies develop proper descriptive vocabularies, singular relationships of grouping, idosyncratic methods at site-dependent or period-dependent scales
\end{itemize}

Furthermore, at the graphical units level, top-down hierachical typologies (e.g., a category of graphical units with \emph{n} types, a type with \emph{n} subtypes, a subtype with \emph{n} varieties, etc.) lead also to tedious inventories and difficult the comparisons \emph{within} and \emph{between} the categories.

These issues limit drastically the possibility to conduct cross-cultural comparisons and to draw a synthesis of humankind's symbolism at a large scale and over the long-term.

According to us, prehistorical composition -- like any formal system -- are spatial features (mostly shapes) related one with the other depending on rules of spatial proximities. Then, the First Law of Geography: "\emph{everything is related to everything else, but near things are more related than distant things}" \citep{Tobler70} should be more operative than the Saussurian '\emph{linearity of the signifier}' principle \citep{Saussure89}. To get these '\emph{near things}', or features proximities, we use concepts coming from the Graph Theory, which offers a general framework to manage neighbourhoods, and particularly relative neighborhood graphs (RNG) which is '\emph{a powerful model of low-level visual process}' \citep{Toussaint80}. Furthermore, we address the questions of managing graphical units attributes (for example an anthropomorph with a sword \emph{vs} an anthropomorph with a spear) and superimpositions of graphical units.  

In this article we present the \proglang{R} package \pkg{decorr}. Its purpose is to formalise a method and offer tools to analyse any graphical content (here: decorations) with methods coming from raph Theory, GIS and binary topological relationships (\emph{birel}) modeling. This package has been grounded on the seminal work of \citet{Alexander08} and its first IT implementation by \citet{Huet18a}.

\section[Model]{Graph theory Model} \label{sec:model}

Graph theory offers a conceptual framework and indices (global at the entire graph scale, local at the vertex scale) to deal with notions of networks, relationships and neighbourhoods. Graphical units (GUs) can be modelled as vertices (nodes) separated one with another by undecorated areas. Their spatial relations can be modelled as edges. The different levels of GUs spatial organisation can be retrieve by a relative neighborhood graphs analysis (Graph Theory) and a spatial (GIS) analysis.

Graph elements, nodes and edges -- repectively GUs and connexions between GUs -- are created on a GIS interface. Indeed, for large series of decorated supports, GIS offers the most suitable and flexible interface to register all GUs and to get their coordinates. The decoration image is considerated as the basemap of the project and will cover the region of interest of the analysis (ie, all the graphical content). The decoration image can be binarized: GUs are considerated active, the undecorated parts of the support -- the background -- are considerated inactive. The polygonisation of the GUs (\code{POLYGONS}), including the border of the stelae, allows to calculated their Voronoi seeds (ie, their centroid) and Voronoi cells (ie, their area of influence). So, the entire decoration image is tiled and condidered as a Voronoi diagram. Centroids of the GUs (\code{POINTS}) are calculated and considered as the graph nodes, their locations (\emph{x} and \emph{y} coordinates, measured in pixels) are relative to each decoration. Exist edges (\code{LINES}) between pairs of GUs when their Voronoi cells share a common border (\emph{birel}: 'touches').

The entire graphical content of the decoration is mapped with a neighborhood graphs (RNG) -- ie geometric graph, or planar graph -- of GUs centroids (nodes) and GUs proximity links (edges). So, a decoration graph is a one component graph. This graph is the dual graph of the decoration Voronoi diagram (Fig. \ref{fig:gis}).

\begin{figure}[H]
% \begin{figure}[!htbp]
\centering
\includegraphics{gis}
\caption{\label{fig:gis} GIS interface. A) Original decoration of the Late Bronze Age Cerro Muriano 1 stelae (drawing: \cite{DiazGuardamino10}) opened in new GIS project without any projection system with its extent (\code{xmin, xmax, ymin, ymax} in pixels); B) Polygonisation of the GUs, calculation of their centroids (nodes), calculation of the Voronoi cells, calculation of the proximity links (edges); C) plot of the relative \emph{x} and \emph{y} coordinates of the GUs centroids; D) plot of the values in the \code{type} of the GUs}
\end{figure}

Whether this theoritical process include image binarization, polygonization and \emph{birel} analysis, a simplier solution will be to create directly centroids on the GUs and to draw the edges manually. Then \emph{x} and \emph{y} coordinates of nodes can be easily retrieved.\\

\subsection[elements]{Graph elements} \label{sec:elements}

This model has a minimal of \emph{a priori} definitions. Those definitions only concern the graph elements: nodes variables (ie, GUs variables) and types of relations they share (edges). 

\smallbreak
\textbf{Nodes types}
\\
At least one variable, like the \code{type} of the nodes, is defined in order to analyse and compare iconographical compositions. In this article, we will only consider nodes \code{type} values ('anthropomorph', 'sword', etc.) but it the package user can add other variables (\code{technique}, \code{color}, etc.)

\smallbreak
\textbf{Egdes types}
\\
The package considers the most common types of relations between nodes: 

\begin{description}
\item[\emph{normal edges}]
Two contemporaneous nodes having a Voronoi cell sharing a border have a common edge. By convention, this edge is tagged \code{'='} (\code{type = '='}), represented with an orange plain line and its textual notation is \code{'-=-'}. For example: \code{personnage -=- bouclier} means that the nodes \code{personnage} and \code{bouclier} have a common border (Fig. \ref{fig:gis_1}). As said, in Prehistorical iconography, the read direction is not known, so this edge is undirected, ie \code{personnage -=- bouclier} is equal to \code{bouclier -=- personnage} (Fig. \ref{fig:gis_1}).

\item[\emph{attribute edges}]
It occurs frequently that a node can be divided into a main unit (eg, an anthropomorph) and one or various attribute units (eg, a helmet, a male sex). To record this ordered set, the edge between a main and an attribute node is tagged \code{'+'} (\code{type = '+'}), represented with an orange dashed line and its textual notation is \code{'-+-'}. For example \code{personnage -+- casque} means that the main node \code{personnage} has the attribute node \code{casque}. The edge is directed since \code{personnage -+- casque} (the anthropomorph has an helmet) is not equal to \code{casque -+- personnage} (the helmet has an anthropomorph) (Fig. \ref{fig:gis_1}).

\begin{figure}[H]
% \begin{figure}[!htbp]
\centering\emph{}
\includegraphics[height=10cm, trim=15mm 20mm 15mm 20mm, clip, keepaspectratio]{gis_1}
\caption{\label{fig:gis_1} GIS interface, Cerro Muriano 1 decoration. The nodes \code{casque} (helmet) and \code{sexe\_masculin} (male sex) are two nodes attributes of the node \code{personnage} (anthropomorph).}
\end{figure}

Broadly speaking, for further statistical analysis, it is better to use this \emph{attribute} method than to multiply the categories of nodes.

\item[\emph{overlapping edges}]
Finally, it occurs that a graphical composition shows decoration phases. These decoration phases can be identified by observing the superimpositions between different nodes or by other means (the technique or the patina for example). In the first case, two nodes belonging to two different phase will have a common part (the overlapped intersection) while in the second case the two nodes will not necessarly share a part of their surface. To record this relative chronology, an edge between two non-contemporaneous nodes is tagged \code{'>'} (\code{type = '>'}), represented with a blue plain line and its textual notation is \code{'->-'}. For example \code{ecriture ->- bouclier} means that \code{ecriture} is more recent than the \code{bouclier}, or \emph{overlaps} the\code{bouclier} in the stratigraphical sense. The edge is directed since \code{ecriture ->- bouclier} (ie, \code{ecriture} \emph{overlaps} \code{bouclier} ) is not equal to \code{bouclier ->- ecriture} (ie, \code{bouclier} \emph{overlaps} \code{ecriture}) (Fig. \ref{fig:gis_2}).

\end{description}

\begin{figure}[H]
% \begin{figure}[!htbp]
\centering
\includegraphics[height=10cm, trim=30mm 16mm 30mm 13mm, clip, keepaspectratio]{gis_2}
\caption{\label{fig:gis_2} GIS interface, Ibahernando decoration. The node \code{ecriture} (writing) overlaps \code{lance} (spear) and the upper part of the \code{bouclier} (shield).}
\end{figure}

This stratigraphical information (node 1 \emph{over} node 2, or node 2 \emph{under} node 1) helps to understand the relative chronology between node and must be recorded. The analysis of the iconographical content can be stratified (stratified analysis) and performed on each different phases of decoration separately. 

These different relationship types are resumed with their birel equivalencies in Table \ref{table:tedges}.

\begin{table}[!htbp]
\centering
\begin{tabular}{ccccp{2cm}p{4.9cm}}
\hline
% node A & type of edge & node B & undirected & birel & stratigraphical meaning \\
Node 1 & Edge type & Node 2 & Edge directness & \emph{Birel} & Description \rule{0pt}{1em} \\[1pt]
\hline \rule{0pt}{1em}%
\code{A} & \code{=} & \code{B} & Undirected & $ A \cap B = \emptyset $ & 
\code{A} and \code{B} are contemporaneous and disjoint. \\
\code{A} & \code{+} & \code{B} & Directed & $ A \cap B = A $ & 
\code{A} and \code{B} are contemporaneous. \code{B} is an attribute of \code{A}. \\
\code{A} & \code{>} & \code{B} & Directed & $ A \cap B = \exists $ \newline or \newline $ A \cap B = \emptyset $ & 
\code{A} is more recent than \code{B}. \\
% \code{1} & = & 2 & undirected & A \cap B = \varnothing & 1 and 2 can be contemporaneous \\
\hline
\end{tabular}
\caption{Synthesis for the different types of relations between GUs.}\label{tab1}
\label{table:tedges}
\end{table}

\section{The R package decorr} \label{sec:models}

<<results='asis', include=FALSE, echo=FALSE, warning=FALSE>>=
library("decorr")
library("igraph")
library("magick")
@
%
The \pkg{decorr} package can be downloaded from GitHub
%
\begin{CodeChunk}
\begin{CodeInput}
R>   devtools::install_github("zoometh/iconr", build_vignettes=TRUE)
\end{CodeInput}
\end{CodeChunk}
%

\subsection{External package} \label{sec:ext_pck}

The \pkg{decorr} package imports the following packages:
\begin{itemize}
\setlength\itemsep{.1em}
\item \pkg{magick} for image manipulation \citep{Ooms18}
\item \pkg{igraph} for graph and network analysis \citep{Csardi06}
\item \pkg{rgdal}  to read \emph{shapefiles} of nodes and edges \citep{Bivand19}
\item \pkg{grDevices} for colors and font plotting, \pkg{graphics} for graphics, \pkg{utils} and \pkg{methods} for formally defined methods and \emph{varia} methods (all combinations, etc.) \citep{R19}
\end{itemize}

\subsection{Data} \label{sec:ext_data}

A training dataset (nodes and edges coordinates, decoration images) is stored in the \code{extdata} folder of the \pkg{decorr} package
\smallbreak
% \begin{itemize}
% \item The \code{imgs} dataframe
% \end{itemize}
\textbf{\code{imgs} dataframe}
\\
The inventory of decorations is stored in the \code{imgs} dataframe (Tab. \ref{tab:timg}). The field \code{imgs$idf} is the short name of the decoration, useful during statistical analysis. The primary key of each decoration is the concatenate of \code{imgs$site} and \code{imgs$decor}. These keys will allow joints with the other dataframes (\code{nodes} and \code{edges})
%
<<results='asis', echo=FALSE, warning=FALSE>>=
imgs <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
                   sep="\t", stringsAsFactors = FALSE)
print(xtable::xtable(imgs,
                     caption="The studied corpus, the \\code{imgs.tsv} dataframe",
                     label="tab:timg",
                     size=6,
                     align=c(
                       "p{0.01cm}",
                       "c",
                       ">{\\raggedright\\arraybackslash\\rule{0pt}{1em}\\addtolength{\\baselineskip}{-1.5pt}}p{2.1cm}",
                       ">{\\raggedright\\arraybackslash\\addtolength{\\baselineskip}{-1.5pt}}p{2.1cm}",
                       "p{8.5cm}")),
      table.placement="!htbp",
      include.rownames=FALSE)
@
%
The \pkg{decorr} package training dataset is composed by five stelaes decorations drawings \citep{DiazGuardamino10} belonging to the so-called 'Warrior stelae' family -- with about 140 stelae -- dated to the Late Bronze Age of SW Iberian peninsula \citep{Celestino01}. \\
At first the drawings dataset can be checked by using the \code{imgs} dataframe and the \pkg{magick} package (Fig. \ref{fig:dataset})
%
<<timg, echo=TRUE, message=FALSE, warning=FALSE, fig.pos = '!htbp', fig.align="center", fig.width=15, fig.height=11.2, fig.cap="\\label{fig:dataset}Decoration images of the training dataset">>=
pth <- system.file("extdata", package = "decorr")
imgs <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
                   sep="\t", stringsAsFactors = FALSE)
lims <- list()
for(i in 1:nrow(imgs)){
  i1 <- image_read(paste0(pth,"\\",imgs[i,"img"]))
  lbl.txt <- paste0(imgs[i,"idf"],"\n",
                    imgs[i,"site"],"\n",
                    imgs[i,"decor"],"\n",
                    imgs[i,"img"],"\n",
                    image_info(i1)$width,"*",image_info(i1)$height," px")
  i1 <- image_annotate(i1,lbl.txt,location = "northwest",
                       size = 28, color = "red")
  lims[[length(lims)+1]]<- i1
}
out.img <- image_append(c(image_append(c(lims[[1]],lims[[2]],lims[[3]])),
                          image_append(c(lims[[4]],lims[[5]]))),
                        stack = TRUE)
par(mar=c(0,0,0,0))
plot(out.img)
@
%
To construct a graph overlapping the decoration images listed in the \code{images} dataframe, the first step is to load \code{nodes} and \code{edges} dataframes.
% \begin{itemize}
% \item The \code{nodes} dataframe
% \end{itemize}
\smallbreak
\textbf{Nodes dataframe}
\\
It contains the required minimum variables for the analysis (Tab. \ref{tab:tnds}).

<<tndss, results='asis', echo=TRUE>>=
caption <- "Nodes (from \\code{nodes.csv} dataframe)"
nodes <- read.table(system.file("extdata", "nodes.csv", package = "decorr"),
                    sep=";",stringsAsFactors = FALSE)
print(xtable::xtable(head(nodes),
                     caption = caption,
                     label="tab:tnds"),
      table.placement="!htbp")
@

Since a prehistorical site can have various decorated objects, the primary key of the decoration is based on two fields: \code{nodes$site} and \code{nodes$decor}. The \code{nodes$id} is the identifier of the node. The \code{nodes$type} field is the default variable for further statistical analysis. Here, \code{nodes$type} refers to the typology of the nodes (anthropomorph, weapons, etc.). The \code{nodes$x} and \code{nodes$y} columns refer to the \emph{x} and \emph{}y coordinates of the nodes. As said, in the first place theses coordinates come from the GIS. But, in a GIS, the coordinates origin (0, 0) is the bottom-left corner and exist negative values, while this origin is top-left for any \proglang{R} matrices (rasters, grids, dataframes, etc.) with only positive values. To recover the local \emph{y} value of nodes and edges on the decoration image, the absolute value \emph{y} value and the image height, as a constant offset, are computed.
\smallbreak
% \begin{itemize}
% \item The \code{edges} dataframe
% \end{itemize}
\textbf{\code{edges} dataframe}
\\
The \code{edges} dataframe is quite similar to the \code{nodes} dataframe (Table \ref{tab:teds}).

<<tedss, results='asis', echo=TRUE>>=
caption <- "Edges of Cerro Muriano 1 (from \\code{edges.csv} dataframe)"
edges <- read.table(system.file("extdata", "edges.csv", package = "decorr"),
                    sep=";",stringsAsFactors = FALSE)
edges.cm1 <- subset(edges, decor == "Cerro Muriano 1")
print(xtable::xtable(head(edges.cm1),
                     caption=caption,
                     label="tab:teds"),
      table.placement="!htbp")
@

Fields \code{edges$site} and \code{edges$decor} are the primary key of decoration. The fields \code{edges$a} and \code{edges$b} are the equivalent to columns \emph{from} and \emph{to} in Graph theory. Even if undirected graphs will the most common in further studies, this direction helps to distinguish between nodes. The column \code{edges$a} is the identifier of \emph{starting node} or \emph{main node} or \emph{overlapping node}. The column \code{edges$b} is the identifier of the \emph{ending node} or \emph{attribue node} or \emph{overlapped node}. The column \code{edges$type} is the type of relation (normal, attribute, overlapping, etc.) between the node a and the node b. There is no need to record the coordinates of the edges, these coordinates are calculated from the \code{nodes} dataframe. 

The \pkg{decorr} package functions can be divided into:
\begin{enumerate}
\item management functions
\item graphical functions
\item single decoration functions
\item comparisons between different decorations functions
\end{enumerate}

Once these dataframes loaded, the list of decoration graphs can be calculated with \code{list_dec()}.

\subsection{Management functions} \label{sec:manage}

\end{Begin}
list_dec(imgs,
         nodes,
         edges)
\end{Code}

Once \code{imgs}, \code{nodes} and \code{edges} dataframes loaded, the \code{list\_dec()} function allows to create graphs for all decorations within these dataframes. The result is a list of \code{igraph} objects. As an example, the first graph of the list can be plotted with the \code{igraph::plot()} function (Fig. \ref{fig:igraph})

<<igraphs, echo=TRUE, message=FALSE, warning=FALSE, fig.pos = '!htbp', fig.align="center", fig.width=2.5, fig.height=2.5, fig.cap="\\label{fig:igraph}R interface. Plot of the first graph of the list (Cerro Muriano 1 decoration)">>=
lgrph <- list_dec(imgs, nodes, edges)
par(mar=c(0, 0, 0, 0))
plot(lgrph[[1]],
     vertex.color = "orange",
     vertex.frame.color = "orange",
     vertex.label.color = "black",
     vertex.size = 16,
     vertex.label.cex = 1,
     edge.color = "orange",
     vertex.label.family = "Helvetica"
)
@

\begin{Code}
named_elements(grph,
               focus = "edges",
               nd.var = "type")
\end{Code}

The \code{named\_elements()} function allows to calculate the textual expression of graph elements (nodes and edges) with a disambiguation of these elements -- adding '#' suffixes -- when several nodes or edges have the same values. 

<<named, echo=TRUE, message=FALSE, warning=FALSE, fig.pos = '!htbp', fig.align="center", fig.width=2.5, fig.height=2.5, fig.cap="\\label{fig:igraph}R interface. Plot of the first graph of the list (Cerro Muriano 1 decoration)">>=
lgrph <- list_dec(imgs, nodes, edges)
as.character(named_elements(lgrph[[2]], focus = "edges", nd.var="type"))
as.character(named_elements(lgrph[[2]], focus = "nodes", nd.var="type"))
@

\subsection{Graphical functions} \label{sec:functions_gr}

The \pkg{decorr} package has two graphical functions.

\begin{Code}
labels_shadow(x, y = NULL, labels,
col = "black", bg = "white",
theta = seq(0, 2 * pi, length.out = 50),
r = 0.1,
cex = 1, ...)
\end{Code}

\code{labels_shadow()} is a re-use of the \code{shadowtext()} function from the \pkg{TeachingDemos} package \citep{Snow20}. It plots labels (\code{labels}) at specific coordinates (\code{x, y}) with a contrasting buffer to make them more visible.

\begin{Code}
side_plot(grp, doss, nd.var, focus = "nodes",
          nd.color = c("orange", "red"),
          nd.size = c(0.5, 1),
          ed.color = c("orange", "red"),
          ed.width = c(1, 2),
          lbl.size = 0.5)
\end{Code}

\code{side_plot()} allows to plot two decoration graphs side-by-side for elements (nodes or edges) comparisons. It take a list of two graph (\code{grp}), the path of the working directory (\code{doss}) and the name of the studied node variable (\code{nd.var}) and return an image.

\subsection{Single decoration functions} \label{sec:functions_one}

Functions allowing to create a RNG for a single decoration are \code{read\_nds()} and \code{read\_eds()}. These functions allow to read respectively a file of nodes and a file of edges (\code{.csv}, \code{.tsv} or \code{.shp} files). 

\begin{Code}
read_nds(site,
         decor,
         doss = getwd(),
         nodes = "nodes",
         dev = ".tsv")
\end{Code}

\code{read_nds()} is close to the \proglang{R} native \code{read.table()} function, but allows to read \emph{shapefiles} of nodes. For example, for the Torrejon Rubio 1 decoration, the node 6 is a sword (\code{epee}) (Table \ref{tab:nd}).

<<nd, results='asis', echo=TRUE>>=
caption <- "Torrejon Rubio 1 decoration node 6: the sword"
sit <- "Torrejon Rubio" ; dec <- "Torrejon Rubio 1"
nds.df <- read_nds(site = sit, decor = dec, dev = ".shp",
                   doss = system.file("extdata", package = "decorr"))
print(xtable::xtable(nds.df[nds.df$id == 6, ],
                     caption = caption,
                     label = "tab:nd",
                     size = 7),
      table.placement = "!htbp")
@

\begin{Code}
read_eds(site,
         decor,
         doss = getwd(),
         edges = "edges",
         nodes = "nodes",
         dev = ".tsv")
\end{Code}

\code{read_eds()} permits to read a \emph{shapefiles} of edges (\code{dev = ".shp"}) or, when the data source is a \code{.csv} or \code{.tsv} dataframe, to retrieve the coordinates of the edges from the \code{nodes} dataframe (Table \ref{tab:ed}).

<<ed, results='asis', echo=TRUE >>=
caption <- paste0("First edge of the Torrejon Rubio 1 decoration, ",
                  "the proximity between the sword (node 6) ",
                  "and the fibula (node 5)")
eds.df <- read_eds(site = sit, decor = dec, dev = ".tsv",
                   doss = system.file("extdata", package = "decorr"))
print(xtable::xtable(eds.df[1,],
                     caption = caption,
                     label = "tab:ed",
                     size = 7),
      table.placement = "!htbp")
@
% \end{figure}

% \begin{itemize}
% \setlength\itemsep{.1em}
% \item \code{plot_dec_grph()} allows to plot a RNG over a decoration image
% \end{itemize}

\begin{Code}
plot_dec_grph(nodes = NULL,
              edges = NULL,
              site,
              decor,
              doss = getwd(),
              nd.var = 'id',
              nd.color = 'orange', nd.size = 1.7,
              lbl.color = 'black', lbl.size = 1.2,
              ed.color = c("orange", "blue"), ed.lwd = 4,
              img.format = "png")
\end{Code}

\code{plot_dec_grph()} allows to plot a RNG over a decoration image. Once, the \code{imgs}, \code{nodes} and \code{edges} dataframes have been read, the graph of a specific decoration (\code{site} and \code{decor} parameters) is build and plotted. The \code{nd.var} parameter allows to decide which field of the nodes will be displayed as the label, by default this is the \code{nodes$id} field. For example, we can plot the graph of the Torrejon Rubio 1 decoration with the type of the nodes (Figure \ref{fig:trst}).

<<trst, echo=TRUE, message=FALSE, warning=FALSE, fig.pos = '!htbp', fig.align="center", fig.width=4, fig.asp=1, fig.cap="\\label{fig:trst}Torrejon Rubio 1 decoration">>=
# library("decorr")
par(mar=c(0,0,0,0))
sit <- "Torrejon Rubio" ; dec <- "Torrejon Rubio 1"
nds.df <- read_nds(site = sit, decor = dec, dev = ".tsv",
                   doss = system.file("extdata", package = "decorr"))
eds.df <- read_eds(site = sit, decor = dec, dev = ".tsv",
                   doss = system.file("extdata", package = "decorr"))
img.graph <- plot_dec_grph(nodes = nds.df,
                           edges = eds.df,
                           site = sit,
                           decor = dec,
                           doss = system.file("extdata", 
                                              package = "decorr"),
                           nd.var = "type",
                           lbl.size=2)
magick::image_read(img.graph)
@

\subsection{Decoration comparison functions} \label{sec:functions_one}

These functions allow to compare different graph decorations. The function \code{list_compar()} is used to compare common nodes and common edges depending on the node variable \code{nd.var}. This function calls \code{nds_compar()} and \code{eds_compar()}

\begin{Code}
list_compar(lgrph,
            nd.var = "type",
            verbose = FALSE)
\end{Code}

Whereas the \code{nd.var} (by default, the column \code{type}) refers to the nodes and can be any other column create by the user (e.g., \code{technique}, \code{color}, etc.), the comparisons always take into account the field \code{type} (\code{=}, \code{+}, \code{>}, ...) of the edges.
Comparisons are done between one or more pairwise of decorations. In the training dataset, there are five (5) decorations in the default dataset, so there is $\frac{5!}{(5-2)!2!}={10}$ possible pairwise comparisons

\code{plot_compar()} allows to plot and save two figures side-by-side for one or more pairwise of decorations for common elements.

\begin{Code}
plot_compar(listg, graph2 = NULL, focus = "nodes",
            doss = getwd(),
            nd.color = c("orange", "red"), nd.size = c(0.5, 1),
            ed.color = c("orange", "red"), ed.width = c(1, 2),
            lbl.size = 0.5, img.format = "png", res = 300)
\end{Code}
% \begin{itemize}
% \setlength\itemsep{.1em}
% \item \code{plot_nds_compar()} and \code{plot_eds_compar()} functions allow to plot and save two figures side-by-side for a decorations pairwise with, respectively, common nodes and common edges identified
% \end{itemize}
\code{plot_compar()} takes a list of graphs \code{listg}, created previously by \code{list_compar()}, and a vector with the ids of the graphs to compare (\code{graph2}). The function creates an image for each pairwise comparison with the decorations plotted side-by-side with elements: common nodes (\code{focus = "nodes"}, by default) or common edges (\code{focus = "edges"}). For each pairwise, if an element exists only in one decoration, it is displayed in orange by default (\code{nd.color[1]} or \code{ed.color[1]}). When an element is present on the two decorations, it is displayed in red by default (\code{nd.color[2]} or \code{ed.color[2]}). The function returns the paths to the created images.

Let us choose the decorations 1 (Cerro Muriano 1) and 4 (Zarza de Montsanchez) and identify common edges (Figure \ref{fig:ceds}).

<<echo=TRUE, message=FALSE, warning=FALSE, fig.pos = '!htbp', fig.align="center", fig.width=8, fig.height=4.2, fig.cap="\\label{fig:ceds}Comparisons between decoration 1 (Cerro Muriano 1) and decoration 4 (Zarza de Montsanchez)">>=
par(mar=c(0,0,0,0))
g.compar <- list_compar(lgrph, "type")
eds_compar <- plot_compar(g.compar, c(1, 4),
                          focus = "edges",
                          doss = system.file("extdata", package = "decorr"))
plot(magick::image_trim(magick::image_read(eds_compar)))
@

The comparison shows that \code{1} (Cerro Muriano 1) and \code{4} (Zarza de Montsanchez) decorations have two (2) common edges: \code{lance -=- personnage} and \code{personnage -=- bouclier}.

\code{same_elements()} function allows to count matching nodes and matching edges between decoration pairwises.

\begin{Code}
same_elements(lgrph,
              nd.var = "type",
              focus = "nodes")
\end{Code}

The \code{same_elements()} function take the list of graphs (\code{lgrph}) produced by \code{list_dec()} and the node variable on which the comparison will be done, by default \code{type} (\code{nd.var = "type"}). The result is a square matrix between all pairwise comparisons with the number of common elements (nodes or edges in the cells). The diagonal of the square matrix show the total number of element for a given decoration. For example, we can compute the matrix of common edges (Table \ref{tab:mat.ed}).

<<results='asis', echo=TRUE>>=
df.same_edges <- same_elements(lgrph, "type", "edges")
caption <- "Number of common edges between all graph decoration pairwises"
print(xtable::xtable(df.same_edges,
                     caption = caption,
                     label = "tab:mat.ed",
                     size = 8,
                     digits = c(0)),
      table.placement="!htbp",
      include.rownames = TRUE)
@

The edges comparisons between the decoration 1 and the decoration 4 show that they have two (2) common edges, see also the Figure \ref{fig:ceds}.

\section{Illustrations} \label{sec:illustrations}

In order to demonstrate the main insight of a graph-based analysis of the decorations, we will compare two classifications, the first one based on the "classic" presence of common nodes -- since the precise location of the nodes is usualy not registred in the studies --, the second one based on the presence of common edges. 

At first, the Late Bronze Age phase of Ibahernando stelae must be selected (ie, the Roman latin writing must be removed). After the selection of the graph elements of Ibahernando, the connected component of the node 2, the lance (spear), is selected with \code{contemp_nds()} and the list of graphs (\code{lgrph}) is updated

<<results='asis', echo=TRUE, fig.height= 5>>=
dataDir <- system.file("extdata", package = "decorr")
# Read a decoration
nds.df <- read_nds(site = "Ibahernando",
                   decor = "Ibahernando",
                   doss = dataDir)

eds.df <- read_eds(site = "Ibahernando",
                   decor = "Ibahernando",
                   doss = dataDir)
# Extract the graph contemporaneous to the node 2
l_dec_df <- contemp_nds(nds.df, eds.df, selected.nd = 2)
# remove first co
l_dec_df[[1]]$site <- l_dec_df[[1]]$decor <- NULL
l_dec_df[[2]]$site <- l_dec_df[[2]]$decor <- NULL
g <- graph_from_data_frame(l_dec_df[[2]], vertices = l_dec_df[[1]],
                           directed = FALSE)
# re-add the site and decor columns 
# with Ibahernando values and the graph name
g$site <- g$decor <- "Ibahernando"
g$name <- 5
# overwrite the decor in the list
lgrph[[5]] <- g
@

Then, \code{same_elements()} is done on nodes and edges (Table \ref{tab:common.elts})

<<results='asis', echo=TRUE>>=
df.same_edges <- same_elements(lgrph, "type", "edges")
df.same_nodes<- same_elements(lgrph, "type", "nodes")
@

\begin{table}[!htbp]
% \begin{table}[H]
\centering
\begin{minipage}{.3\textwidth}
\centering
\textbf{Common nodes}\raisebox{-1ex}{}\\
<<echo=FALSE,results='asis' >>=
print(xtable::xtable(df.same_nodes,
                     size = 8,
                     digits = c(0)),
      floating=FALSE,
      include.rownames = TRUE)
@
\end{minipage}
\begin{minipage}{.3\textwidth}
\centering
\textbf{Common edges}\raisebox{-1ex}{}\\
<<echo=FALSE,results='asis'>>=
print(xtable::xtable(df.same_edges,
                     size = 8,
                     digits = c(0)),
      floating=FALSE,
      include.rownames = TRUE)
@
\end{minipage}
\caption{Tables showing the number of common nodes and common edges between each pair of decorations}
\label{tab:common.elts}
\end{table}

% the inverse values of common nodes and common edges are calculated with the function \code{inv()} from the package \pkg{matlib} \citep{Friendly20}, and then 
Once the heatmap matrices calculated, the distance matrices are calculated with the native \code{dist()} function \citep{R19} (Table \ref{tab:dist.elts}).

\begin{table}[!htbp]
% \begin{table}[H]
\centering
\begin{minipage}{.4\textwidth}
\centering
\textbf{Distance matrix on nodes}\raisebox{-1ex}{}\\
<<echo=FALSE,results='asis', warning=F >>=
library("matlib")
dist.nodes  <- dist(as.matrix(df.same_nodes))
mat.nodes <- as.matrix(dist.nodes)
mat.nodes[lower.tri(mat.nodes, diag = TRUE)] <- NA
print(xtable::xtable(mat.nodes,
                     size = 8,
                     digits = c(2)),
      floating=FALSE,
      include.rownames = TRUE)
@
\end{minipage}
\begin{minipage}{.4\textwidth}
\centering
\textbf{Distance matrix on edges}\raisebox{-1ex}{}\\
<<echo=FALSE,results='asis'>>=
dist.edges <- dist(as.matrix(df.same_edges))
mat.edges <- as.matrix(dist.edges)
mat.edges[lower.tri(mat.edges, diag = TRUE)] <- NA
print(xtable::xtable(mat.edges,
                     size = 8,
                     digits = c(2)),
      floating=FALSE,
      include.rownames = TRUE)
@
\end{minipage}
\caption{Distance matrices on nodes and common edges between each pair of decorations}
\label{tab:dist.elts}
\end{table}

For both nodes and edges, the results show that the most important differences are between the decoration 1 and the decoration 2: for nodes, dist = \Sexpr{round(max(mat.nodes, na.rm = T), 2)} ; for edges, dist =  \Sexpr{round(max(mat.edges, na.rm = T), 2)}. At the opposite, the decorations showing the more similar compositions are decoration 3 and decoration 5: for nodes, dist = \Sexpr{round(min(mat.nodes, na.rm = T), 2)} ; for edges, dist =  \Sexpr{round(min(mat.edges, na.rm = T), 2)}.
A hierachical clustering (HC) of the distance matrices, with the native function \code{hclust()} \citep{R19}, summarize these similarites/dissimilarities (Figure \ref{fig:hclust})

\begin{figure}[H]
% \begin{figure}[!htbp]
<<echo=TRUE, warning=FALSE, fig.height=5>>=
par(mfrow=c(1,2))
# dist.nodes  <- dist(inv(as.matrix(df.same_nodes)))
# dist.edges  <- dist(inv(as.matrix(df.same_edges)))
# plot(hclust(dist.nodes), hang = -1, main = "common nodes")
# plot(hclust(dist.edges), hang = -1, main = "common edges")
plot(hclust(dist.nodes), main = "common nodes")
plot(hclust(dist.edges), main = "common edges")
@
\label{fig:hclust}
\end{figure}

These latter decorations (decoration 1 and decoration 2) can be plotted with \code{plot_compar()} to vizualise the common elements (Figure \ref{fig:dec1.dec2}).

\begin{figure}[H]
<<echo=TRUE, message=FALSE, warning=FALSE, fig.pos = '!htbp', fig.align="center", fig.cap="\\label{fig:dec1.dec2}Decoration comparisons between decoration 1 and decoration 2">>=
par(mar = c(0, 0, 0, 0))
par(mfrow = c(2, 1))
lgrph <- list_dec(imgs, nodes, edges)
g.compar <- list_compar(lgrph, "type")
nds_compar <- plot_compar(g.compar, c(3, 5),
                          focus = "nodes",
                          nd.size = c(0.5, 1.5),
                          ed.width = c(1, 2.5),
                          lbl.size = .7,
                          doss = system.file("extdata", 
                                             package = "decorr"))
plot(magick::image_read(nds_compar))
eds_compar <- plot_compar(g.compar, c(3, 5),
                          focus = "edges",
                          nd.size = c(0.5, 1.5),
                          ed.width = c(1, 2.5),
                          lbl.size = .7,
                          doss = system.file("extdata", 
                                             package = "decorr"))
plot(magick::image_read(eds_compar))
@
\label{fig:dec1.dec2}
\end{figure}

Even the classifications on nodes and edges give the same results, 

%% -- Summary/conclusions/discussion -------------------------------------------

\section{Summary and discussion} \label{sec:summary}

In this example we propose the iconographical \code{nodes$type} (character, weapon, etc.) nodes as the studied variable, but the user of the package can create and choose any other study variable: color for a painting, technique of realisation, size, etc.
\code{edges$type} can also be extended to other types than normal, attribute, overlapping.
The background is considered as homogeneous but a crack, a pit, a something can also be considered
The plasticity of Graph Theory allows to develop conventions in order to quote the different types of relations s.
Its geographical equivalent is a Thiessen polygon




\section*{Acknowledgments}

\begin{leftbar}
All acknowledgments (note the AE spelling) should be collected in this
unnumbered section before the references. It may contain the usual information
about funding and feedback from colleagues/reviewers/etc. Furthermore,
information such as relative contributions of the authors may be added here
(if any).
\end{leftbar}


%% -- Bibliography -------------------------------------------------------------
%% - References need to be provided in a .bib BibTeX database.
%% - All references should be made with \cite, \citet, \citep, \citealp etc.
%%   (and never hard-coded). See the FAQ for details.
%% - JSS-specific markup (\proglang, \pkg, \code) should be used in the .bib.
%% - Titles in the .bib should be in title case.
%% - DOIs should be included where available.

\bibliography{bibref}


%% -- Appendix (if any) --------------------------------------------------------
%% - After the bibliography with page break.
%% - With proper section titles and _not_ just "Appendix".

\newpage

\begin{appendix}

\section{More technical details} \label{app:technical}

\begin{leftbar}
Appendices can be included after the bibliography (with a page break). Each
section within the appendix should have a proper section title (rather than
just \emph{Appendix}).

For more technical style details, please check out JSS's style FAQ at
\url{https://www.jstatsoft.org/pages/view/style#frequently-asked-questions}
which includes the following topics:
\begin{itemize}
\item Title vs.\ sentence case.
\item Graphics formatting.
\item Naming conventions.
\item Turning JSS manuscripts into \proglang{R} package vignettes.
\item Trouble shooting.
\item Many other potentially helpful details\dots
\end{itemize}
\end{leftbar}


\section[Using BibTeX]{Using \textsc{Bib}{\TeX}} \label{app:bibtex}

\begin{leftbar}
References need to be provided in a \textsc{Bib}{\TeX} file (\code{.bib}). All
references should be made with \verb|\cite|, \verb|\citet|, \verb|\citep|,
\verb|\citealp| etc.\ (and never hard-coded). This commands yield different
formats of author-year citations and allow to include additional details (e.g.,
pages, chapters, \dots) in brackets. In case you are not familiar with these
commands see the JSS style FAQ for details.

Cleaning up \textsc{Bib}{\TeX} files is a somewhat tedious task -- especially
when acquiring the entries automatically from mixed online sources. However,
it is important that informations are complete and presented in a consistent
style to avoid confusions. JSS requires the following format.
\begin{itemize}
\item JSS-specific markup (\verb|\proglang|, \verb|\pkg|, \verb|\code|) should
be used in the references.
\item Titles should be in title case.
\item Journal titles should not be abbreviated and in title case.
\item DOIs should be included where available.
\item Software should be properly cited as well. For \proglang{R} packages
\code{citation("pkgname")} typically provides a good starting point.
\end{itemize}
\end{leftbar}

\end{appendix}

%% -----------------------------------------------------------------------------


\end{document}
